Option D — Object-oriented programming
14.

(a)

(b)

15.

(a)

(b)

(c)

The two constructors have different parameter sets (or equivalent);
Compiler can differentiate between the two;
The compiler will execute the constructor whose parameter set matches the
arguments in the constructor call;
This is an example of polymorphism/overloading;

[3]

Access is restricted to;
(methods that are part of) the same package / project;

[2]

Award [2] for all 3 correct and [1] for any 2 correct.
routeCode is String
delay is int (Note: Allow any numeric)
weatherRelated is Boolean

[2]

“public Journey”;
Correct parameters (Note: Allow FT from part (a));
Correct assignment statements;
Note: Allow any order. Allow absence of “this”.
public Journey(String a, int b, Boolean c)
{
this.routeCode = a;
this.delay = b;
this.weatherRelated = c;
}

[3]

T290;
10;
1;
Note: The punctuation (“;”) is not output.

[3]

– 23 –
16.

N16/4/COMSC/HP2/ENG/TZ0/XX/M

(a)

4.5;

[1]

(b)

Award marks as follows:
Initializing variables used (eg total as a double and count as an integer);
Correct loop;
Correct comparison* (allow getJourney[x]);
Updating total*;
Updating count (in correct position);
Returning average;
Note: *If “get” methods are not used but otherwise correct, award [1] for these
two points.
public double averageDelay()
{
int delayTotal = 0; // Allow total as a double with no
// casting below
int count = 0;
for (int x=0; x<numberOfJourneys; x++)
{
if (!journeyHistory[x].getWeatherRelated())
{
delayTotal = delayTotal +
journeyHistory[x].getDelay();
count++;
}
}
return double(delayTotal)/count;
}

17.

(a)

[6]

Award [1] for each section (award [2] if correct except for +/-).
Allow for slight variations of syntax.
Allow if constructer missing.
Allow public class Codes.
Codes
- routeName : String
- routeCode : String
+Codes(a: String, b: String)
+getRouteName() : String
+getRouteCode() : String

[3]

– 24 –

(b)

N16/4/COMSC/HP2/ENG/TZ0/XX/M

Award marks as follows:
Initialization of maxDelay to be a rogue value or 0, or 1st value;
Award {2 marks] for correct comparison (award 1 mark if weather related
ignored);
Updating of maxDelay;
Updating of maxCode;
Both loops correct;
Searching for route code;
Return route name;
public String longestDelay(Codes [] c)
{
String route = " ";
String maxCode =" ";
int maxDelay =-1;
for (int x = 0; x < numberOfJourneys; x++)
{
if ((journeyHistory[x].getDelay() > maxDelay) &&
(!journeyHistory[x].getWeatherRelated()))
{
maxDelay = journeyHistory[x].getDelay();
maxCode = journeyHistory[x].getRouteCode();
}
}
for (int y=0; y<c.length; y++)
{
if (c[y] != null)
{
if (c[y].getRouteCode() == maxCode)
{
route = c[y].getRouteName();
}
}
}
return route;
}

[7]

– 25 –

18.

(a)

(b)

N16/4/COMSC/HP2/ENG/TZ0/XX/M

A super-class could be created (eg Transport);
With sub-classes Bus, Train and Plane;
Containing variables/methods common to all the different transport
classes/examples;
The individual sub-classes can inherit these common attributes;
Whilst having properties particular to themselves/ can override;
(i)

[4]

Award [1] for a diagram showing five (or more) classes linked in some way.
Award [1] for each of the three different dependencies shown, either with the
correctly shaped arrow or with a written description, up to [3 max].
The dependencies are:
Each of the train company, bus and airplane classes “is a” Transport class;
The train company class “has a” Journey;
The train company class “uses” the Codes class;

Bus
Transport
(superclass)

is a
Plane
Train
uses
Codes

has a
Journey

[4]
(ii)

Changes in one class in a dependency will/may affect the other class(es) in
this dependency;
This may cause programs using the second class not to function
(correctly)/require modifications to the second class to avoid problems;
For example, if the variables in the Codes class changed type then the
TrainCompany etc methods would have to be changed;
(Less dependencies lead to) reduced maintenance overheads;
As a programmer editing one class would not have to be concerned with
other classes / allows programmers to focus just on the class they are
writing;

[3]

– 26 –

(c)

19.

(b)

(a)

N16/4/COMSC/HP2/ENG/TZ0/XX/M

public String toString(Codes [] c)
{
String d = companyName;
double e = averageDelay();
String f = longestDelay(c);
String result = d + " : Average Delay = " + e + " :
Longest Delay = " + f;
return result;
}

Note: Can be written in one line. Students may introduce validation on e.
Award marks as follows:
Extracting company name;
Correct use of averageDelay() method;
Correct use of longestDelay() method;
Correct result line either returned or output;
(Note: Ignore minor punctuation errors/missing parameter);

[4]

Award up to [2 max].
Static arrays are declared which have fixed sizes;
Which may lead to array being too big/small;
The journeyHistory[] array is very large (100 000 possible objects);
Which may lead to wasted memory;
The allCompanies[] array is very small (three objects);
Which may need to be resized;
Any deletions;
May lead to entries being moved up;

[2]

Award up to [5 max].
A (binary) tree will be used;
Set up in order of routeCode;
When a search is made the tree is searched via the root;
1
Moving to the left/right accordingly / eliminating 2 the tree with each comparison;
Until there is a match between the route codes;
The corresponding route name is then returned;

[5]

– 27 –

20.

(a)

(b)

(c)

N16/4/COMSC/HP2/ENG/TZ0/XX/M

Methods are standard / it is clear from the method name what is does;
An example of this;
Only need to know the parameters that have to be passed to these methods;
And the output/result returned;
Adding (continually) to a linked list is very efficient/more efficient than for
an ArrayList; (allow “easier”)
As adding to the front or back just requires adjusting pointers/references;
An ArrayList will need to re-size itself when more entries are required;

[max 3]

[3]

Award marks as follows:
Creating a new ArrayList (or passing one as a parameter);
Adding the first value of allCodes;
Correct while loop (or equivalent);
[2] for checking through previous values for duplicates ([1] for a reasonable
attempt);
The clause that adds to the ArrayList;
Correct assignment of “duplicate” throughout (or equivalent);
Note: An acceptable alternative solution would be to add all entries to the
ArrayList and then remove duplicates.
public void convert()
{
ArrayList n = new ArrayList();
n.add(allCodes[0]);
Boolean duplicate = false;
int x = 1;
while (allCodes[x] != null)
{
for (int y = 0; y<x; y++)
{
if (allCodes[x].getRouteCode() ==
allCodes[y].getRouteCode())
{
duplicate = true;
}
}
if(duplicate == false)
{
n.add(allCodes[x]);
}
duplicate = false;
x++;
}
}

[7]


