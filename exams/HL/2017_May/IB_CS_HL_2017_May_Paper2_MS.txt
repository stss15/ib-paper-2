Option D — Object-oriented programming
13.

(a)

Award up to [3] marks.
Note: An example is required with detailed explanation (up to [2 max];
Award [1 max] if there is lack of detail).
A class describes/provides the template for a particular object;
Whereas an instantiation of a class actually creates an object for that class;
For example:
An employee class would contain characteristics/actions that describe
an employee, and an instantiation would represent a particular employee;

(b)

[3]

Award marks as follows up to [4 max]:
Award up to [2 max] for each of the two required examples (award [1] mark for correct
example but lack of terminology/detail/competence)
Note: Examples should show competent use of terminology in describing the use of
inheritance, to get full marks.
The responses should focus on these aspects, with keywords underlined:
 Several sub-classes can inherit characteristics from a superclass;
 Whilst adding specific characteristics particular to themselves;
Examples can then expand or be described to include the features above.
For example:
There could be a “GUI” superclass that contains the main elements for the UIs
with the GUI for each screen inheriting from its parent;
For example:
An “Employee” superclass that allows the different types of employees to inherit
standard characteristics;

(c)

[4]

Award up to [3 max]:
Library programs are programs that have already been written;
They are standard/frequently used programs;
Development time will be saved if they can be incorporated into the design;
They have been tested / Will be free of bugs;
Note: Allow [1 mark] for responses that include examples that expand on any of the aspects
listed above.
[3]

14.

(a)

Award [max 2 marks]:
[1 mark] for each of the two correct assignments.
public SalesPerson (String id)
{
this.id = id;
salesHistory = new Sales [100];
}

Note: Allow any reasonable value for the number of Sales objects.

[2]

– 43 –
(b)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award up to [3 max].
Note: Use of competent/detailed terminology (underlined) is required.
As the variables are declared as private;
They/their values cannot be accessed directly from outside this class;
Therefore, public accessor methods are needed to permit access;

[3]

Note: Either accessor or access required.
(c)

(i)

Award up to [4 max] as follows (there are 5 marking points):
[1] for two classes BOTH with basic three-tier structure layout;
[1] for correct dependency shown (eg diamond arrow) /
“has a” from SalesPerson to Sales/
1:N relation.
[1] in SalesPerson, for all vars and methods (contentwise) with type
(allow if constructor/ accessor/mutator methods are present);
[1] in Sales, for all vars and methods (contentwise) with type
(allow if constructor/ accessor/mutator methods are present);
[1] for correct use of +/- for public/private;

SalesPerson
- id: String
- salesHistory: Sales[]
- count: int

Sales
- itemId: String
- value: double
- quantity: int

+ double calcTotalSales()
+ Sales largestSale()

[4]

(ii)

Award up to [2 marks].
Any change in the Sales class might require a rewriting of some
SalesPerson methods/might not work;
For example, the calcTotalSales() is dependent upon/uses data from
the Sales
class;

[2]

Note: Accept any reasonable example.
(d)

Award up to [4 marks].
102;
2;
2550.40;
5000.00; (Note: Accept, only in this case, 5000)

[4]

– 44 –
(e)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award marks up to [5 max] as follows:
[1] for assigning an appropriate value to total;
[1] for correct loop;
[2] for correctly updating total OR [1] for a reasonable effort;
[1] for returning the total;
public double calcTotalSales() // returns total value of all
// of the sales
{
double total = 0;
for (int x = 0; x<count; x++)
{
total = total + salesHistory[x].getValue()
*salesHistory[x].getQuantity();
}
return total;
}

[5]

– 45 –
(f)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award marks as follows up to [5 max]:
[1] for correct initialization;
[1] for correct loop;
[1] for correct comparison AND [1] for correct reassignment of total;
Note: Award [1 max] for these two parts if dot notation is not used.
Award [1] for correct re-assignment of index;
public String highest()
{
double total = 0;
int index = -1;
for (int x=0; x<100; x++)
{
if (SalesPeople[x].calcTotalSales() > total)
{
total = SalesPeople[x].calcTotalSales();
index = x;
}
}
return SalesPeople[index].getId();
}

[5]
Note: There will be other correct versions, but the markscheme shown above
should still apply.

– 46 –
(g)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award marks up to [4 max] as follows:
[1] for correct loop;
[1] for correct comparison (either as part of the loop condition, or within a for loop);
[1] for assignment (with or without use of set);
[1] for correct use of get / set methods.
Note: Allow for a “follow through” (FT) if the loop is incorrect
Example of solution with while-loop
public void addSales(Sales s, String id)
{
int x = 0;
while (salesPeople[x].getId() != id)
{
x++;
}
salesPeople[x].setSalesHistory(s);
}

Example of solution with for-loop
public void addSales(Sales s, String id)
{
for(int i=0;i<salesPeople.length; i++)
{
if(salesPeople[i].getId().equals(id))
{
salesPeople[i].setSalesHistory(s);
break;
}
}
}

(h)

[4]

Award up to [3 max]:
A date variable must be added to the Sales class;
And included in its constructor;
Get/set methods added for the date;
The calcTotalSales() would have to be rewritten;
Note: The spirit of the question is to address the question from a programmer/developer
point of view. We are looking for elements of programming/functionality of the programs.
Please take this perspective when marking vague responses.

[3]

– 47 –

(i)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award up to [3 max]:
This is shown by the two constructors in the SalesPerson class;
Which is an example of overloading;
The constructor that is executed (by the compiler);
Is the one in which the parameters match up with the arguments in the calling
statement;

[3]

– 48 –
15.

(a)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award [2] marks for a correct answer (with any variable), and [1] if <Sales> is
missing, but otherwise correct.
private Linkedlist<Sales> salesHistory;

(b)

[2]

Answer using an index:
Award up to [5 max] as follows (there are 6 marking points).
[1] for correct initialization.
[1] for correct calculation of size (or equivalent).
[1] for correct loop.
[1] for correct use of get().
[1] for correct comparison (allow FT if no dot notation).
[1] for correctly updating largest.
public Sales largestSale()
{ double largest = -1;
Sales maxSale = null;
int a = salesHistory.size();
for (int x=0; x<a; x++)
{ Sales s = salesHistory.get(x);
if (s.getValue()*s.getQuantity() > largest)
{ largest = (s.getValue()*s.getQuantity());
maxSale = s;
}
}
return maxSale;
}

Answer using an iterator:
Award up to [5 max] as follows (there are 6 marking points).
[1] for correct initialization of largest and maxSale.
[1] for correct calculation & initialization of the iterator.
[1] for correct loop.
[1] for correct movement through list.
[1] for correct comparison (allow FT if no dot notation).
[1] for correctly updating largest;

public Sales largestSale()
{ double largest = -1;
Sales maxSale = null;
ListIterator<Sales> it = salesHistory.listIterator();
while (it.hasNext())
{ Sales curr = it.next();
double currAmt = curr.getValue() * curr.getQuantity();
if (currAmt > largest)
{ largest = currAmt;
maxSale = curr;
}
}
return maxSale;
}

[5]

– 49 –
16.

(a)

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Award up to [3 max].
Both the variables left and right are examples of reference variables;
They point to the address of another Node object;
Or to null;

(b)

[3]

Award [1] for clearly showing different levels of recursion (labels not required).
Award [1] for showing both recursive calls.
Award [1] for indicating the different nodes addressed.
Award up to [2 max] for a correct trace showing correct output order
(OR [1] for a good attempt that returns a partially correct order)
Note: The focus of this exercise is in addressing dynamical aspects of recursion.
Note: Award up to [2 max] for graphical descriptions that do not address dynamical aspects
of computation but give evidence of [1] five instances of null/empty node, [1] correct
sequence in output in the order 14, 12, 50, 33.

– 50 –

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Example one:
The table develops incrementally top down;
Each row is filled up once and the length of the row indicates the level of nesting of recursive
calls/control;
It shows the calls with the correct argument (accept variants: node2 may be identified as
node1.left);
It contains the actions to be performed (return, print(argument), output(argument));
The order of output is identified by the number in the leftmost column (step);

step
1
2

Nesting of recursion (grows on the right)
print(root)/
print(node1)
print(node1.left)/
print(node2)

3

print(node2.left)

4

return

5

print(node2.right)/
print(node3)

6

print(node3.left)

7

return

8

print(node3.right)

9

return

10

Output 14

11
12

Output 12
print(node1.right)/
print(node4)

13

print(node4.left)

14

return

15

print(node4.right)

16

return

17
18

Output 50
Output 33

– 51 –

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Example two:
This is a more informed and detailed variant of Example one
Note: Not all of the detail shown below is needed and there are various ways of (correctly) showing
this trace.

Level 0
node = node 1
node = null? false
node.left

Level 1

Level 2

Level 3

node = node 2
node = null? false
node.left
node = null
node = null? true
return
node.right
node = node 3
node = null? false
node.left
node = null
node = null? true
return
node.right
node = null
node = null? true
return
output 14
output 12

node.right
node = node 4
node = null? false
node.left
node = null
node = null? true
return
node.right
node = null
node = null? true
return
output 50
output 33

– 52 –

M17/4/COMSC/HP2/ENG/TZ0/XX/M

Example three:
Table constructed top down (implicitly it indicates the step);
It focusses on arguments for the recursive calls and the result of the tests;
the level of recursion is implicit;
It produces the correct output in correspondence of the correctly called arguments;
The sequence of outputs is the last columns read top-down;
Both arguments for the recursive call are displayed;

Node addressed
node 1
node 2
Null
node 4
Null
Null
node 2
node 3
Null
Null
node 1

node == null?
false
false
true
false
true
true
–
false
true
true
–

output
–
–
–
–
–
14
12
–
–
50
33

Example four:
This diagram allows only to retrieve 5 accesses to null ([1] mark); there is no way to reconstruct
the correct sequence in output.
node.left node.right node.data + “ “
12

50

null

null

14

null

null

null

33

– 53 –

M17/4/COMSC/HP2/ENG/TZ0/XX/M

(c) Award [5] marks as follows, depending on a recursive or
non-recursive answer:
Example, non-recursive answer:
Award marks as follows:
[1] correct method signature
[1] declaration/initialisation of current node
[1] correct loop (with correct condition)
[1] update current node with the node on the left
[1] correct data returned (with use of dot notation)

public int smallest(Node node)
{
Node current = node;
while (current.left != null)
{
current = current.left;
}
return(current.data);
}

Example, recursive answer:
Award marks as follows:
[1] correct method signature
[1] correct condition for checking node on the left (conditional statement)
[1] update of node with the node on the left (see NOTE below)
[1] recursive call on smallest
(Note: The recursive call may incorporate the call to the left node)
[1] correct data returned (with use of dot notation)
public int smallest(Node node)
{
if (node.left == null)
{
return node.data;
}
node=node.left;
return smallest(node);
}

Example where Note needs to be applied
public int smallest(Node node)
{
if (node.left == null)
{
return node.data;
}
return smallest(node.left);
}

[5]


