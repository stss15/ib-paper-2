Option D - Object-oriented programming
10.

(a) Award [2 max].
an object is an abstract entity;
consists of data/attributes/properties;
has methods/behaviour/actions on (that data/attributes/properties);
An object occupies memory / has a lifecycle;
An object is an instance of a class;

(b) Award [1 max].
Any instance variable with the prefix 'set' and ( ) such as:
setNumberPlate(String numberPlate);
setPricePerDay(double pricePerDay);
setRentalClass(char rentalClass);
setYear(int year);
SetBrandModel(String brandModel);
SetFuelType(boolean fuelType);
SetTransmissionType(boolean transmissionType);
Note: Ignore the parameter and semi colon.

(c) Award [3 max].
public method;
return type;
correct return;

// keyword 'this' is not required

Example answer:
public String getBrandModel()
{
return this.brandModel;
}

(d) Award [2 max].
A default constructor instantiates an object of a class;
with null or default values (for the instance variables/attributes);
without using any parameter;

(e) Award [2 max].
fuelType can no longer be boolean;
but could be another datatype such as int/char/String (or similar) to represent the distinct
values;
for 4 different types of fuel;

(f) Award [1 max].
Car inherits Rental (allow Car 'is a' Rental or Car extends Rental or Car is a subclass of
Rental.);
Note: Accept 'inheritance'.

(g)

Award [3 max].
Award [1] for (public) class Car extends Rental;
Award [1] for declaring numberOfDoors;
Award [1] for numberOfDoors being set to 4 within the constructor;
Award [1] for correct getter / setter method;
// keyword 'this' is not required
Example answer:
public class Car extends Rental
{
private int numberOfDoors;
public Car()
{
this.numberOfDoors = 4;
}
public int getNumberOfDoors()
{
return this.numberOfDoors;
// ‘this’ not required
}
public void setNumberOfDoors (int n)
{
this.numberOfDoors = n;
// accept without ‘this’ also
}
}

11.

(a) Award [1 max].
Inheritance;

(b) Award [3 max].
Because the parent class holds common attributes and methods;
inheritance will enhance reuse of code;
and reduce maintenance costs;

Faster development time;
as the existing code (base class) is already tested;
and less code needs to be written and debugged;
// Do not accept: 'faster' or 'easier' without proper explanation.
child classes may add new functionality (Extensibility);
extending the parent’s action and data, without redefining them;
child class redefines the base class methods (Overriding);
to provide a different functionality to existing method of the parent class;
easier to maintain;
as the changes in the parent class are automatically reflected in the child class;
Note: Award [2 max] for one benefit with explanation. Award [1 max] for identification of
another benefit. Accept benefits explained for any incorrect but legitimate OOP feature
identified in 15a.

(c) Award [2 max].
Encapsulation;
Polymorphism;
Abstraction;
Note: Allow FT for 15a.

(d) Award [2 max].
Easier / faster to debug/test;
because there are far fewer mistakes in the smaller/individual modules.
Speedier / faster completion of the project;
because different teams work on different modules.
facilitates reusability of the code;
as the existing modules can be reused across other modules.
Improves code readability / organisation;
smaller manageable modules leading to better logical organization.

Note: Do not allow mixing the points from different clusters. Do not allow easier/faster
without any further description in context of modularity.

12.

(a) Award [2 max].
the value/variable passed when the function/method is called;
passed as a value or as a reference;
is found in the parameter list of the method definition/signature;

(b) Award [8 max].
Award [1] for correct method signature (excluding the return type);
Award [1] for instantiating a Car array (result) of size 100;
Award [1] for loop through allCars with length condition;
Award [1] for setting and resetting a variable (found or similar ), inside the outer loop;
Award [1] for the loop that checks the uniqueness
Award [1] for checking for a null pointer exception in at least one loop;
Award [1] for correct test; (use of equals() and ‘==’)
Award [1] for correctly adding the Car when not found in result;
Award [1] for returning the correct result - correct array of objects of Car;
Note: Do not accept ArrayList but allow FT for MP 5 and 7. The question specifically asks for
an array.
Example answer 1:
public Car[] findBrandModels(Car[] allCars)
{
Car[] result = new Car[100];
int i = 0;
while ((i<allCars.length) && (allCars[i]!=null))
{
int j = 0;
boolean found = false;
while ((j<100) && (result[j]!=null) && (!found))
{
if (result[j].getBrandModel().equals(allCars[i].getBrandModel()))
{
found = true;
}
j++;
}
if (!found)
{
result[j] = allCars[i];
}
i++;
}
return result;
}

Example answer 2:
public Car[] findBrandModels(Car[] allCars)
{
int count = 0;
Car[] result = new Car[100];
for (int i = 0; i < allCars.length && allCars[i] != null; i++)
{
boolean found = false;
for (int j = 0; j < i; j++)
{
if(allCars[i].getBrandModel().equals(allCars[j].getBrandModel()))

{
found = true;
}
}
if (!found)
{
result[count++] = allCars[i];
}
return result;
}

Example answer 3:
public Car[] findBrandModels(Car[] allCars)
{
Car[] brand = new Car[100];
int index = 0;
for(int i=0; i<allCars.length && allCars[i]!=null; i++)
{
boolean found = false;
String bm = allCars[i].getBrandModel();
for(int j=0; j<index; j++)
{
if(brand[j]!= null)
{
if(brand[j].getBrandModel().equals(bm))
found = true;
}
}
if(!found)
{
brand[index++] = allCars[i];
}
}
return brand;
}

(c)

Award [5 max].
Example answer 1:
create a result array to store the return value of findBrandModels();
iterate through the result array to check individual Car object;
if the Car object does not fulfil all three criteria then remove this Car object from result / make
this Car object null;
iterate (or sort/search) through the result array;
to output the Car objects that are not null / return the result array;
Example answer 2:
create a result array to store the return value of findBrandModels();
iterate through the result array to check individual Car object;
if an object fulfils the three conditions then copy the car object in another array
(desiredCars);
iterate (or sort/search) through the other array (desiredCars);
to output / return the (desiredCars) array;

Example answer 3:
create a modified version of findBrandModels();
that takes additional parameters that specify desired features;
a car would only be added to the result array if the three tests were met;
create a result array to store the return value of modified findBrandModels();
iterate through the result array to output the cars / return the result array;
Example answer 4:
create a result array to store the return value of findBrandModels();
iterate through the result array to check individual Car object;
if the Car object does not fulfil all three criteria, then skip this Car object
if the Car object meets the three criteria
then output the Car object;
Example answer 5:
create desiredCars array;
iterate through the result of all findBrandModels();
if an object fulfils the three conditions;
copy the car object in the array desiredCars;
to output / return the (desiredCars) array;

Note:
Award [3 max] - If the response doesn’t use the findBrandModels(); For example, if the
response only focuses on using if conditions to check three specific requirements for Car
objects and present (either output or return) them (including duplicates) to the customer.

13.

(a)

Award [1 max].

Customer

Car

(b) Award [2 max].
The problem becomes that Car 'has a' Customer and Customer 'has a' car;
This is a circular / duplicate / redundant relationship;
which may cause inconsistencies;
It increases dependencies;
and causes more overhead when changes need to be made;

(c) Award [5 max].
Award [2] for stating obligations;
Award [2] for amplifications;
Award [2] for reasons given.
obligation - to respect privacy;
amplification - only relevant data should be stored that helps the customer;
reason - to limit the impact on privacy.
obligation - to provide data security;
amplification - programmers should incorporate safeguards such as encryption;
reason - to limit the chance of personal data being misused;
obligation - to protect data against corruption;
amplification - programmers should incorporate data validation / verification;
reason - to limit the chance of incorrect personal data being stored;
Note: Accept any other valid obligation. Do not accept a third obligation.
